const chainId=parseInt(args[0]),blockNumbers=JSON.parse(args[1]),merkleDepth=parseInt(args[2])||8,targetChainId=parseInt(args[3]),proofServiceUrl=args[4]||"https://ed16-103-175-168-222.ngrok-free.app/prove",CHAIN_CONFIGS={1:{rpcUrl:"https://eth.llamarpc.com",fallbackRpcUrls:["https://rpc.ankr.com/eth","https://ethereum-rpc.publicnode.com","https://endpoints.omniatech.io/v1/eth/mainnet/public"],blockTime:12,confirmations:6,minValidBlock:18e6},42161:{rpcUrl:"https://arbitrum-one-rpc.publicnode.com",fallbackRpcUrls:["https://rpc.ankr.com/arbitrum","https://arbitrum.llamarpc.com"],blockTime:1,confirmations:1,minValidBlock:1e8},10:{rpcUrl:"https://optimism-rpc.publicnode.com",fallbackRpcUrls:["https://rpc.ankr.com/optimism","https://optimism.llamarpc.com"],blockTime:2,confirmations:1,minValidBlock:1e8},8453:{rpcUrl:"https://base-rpc.publicnode.com",fallbackRpcUrls:["https://rpc.ankr.com/base","https://base.llamarpc.com"],blockTime:2,confirmations:1,minValidBlock:1e7},137:{rpcUrl:"https://polygon.llamarpc.com",fallbackRpcUrls:["https://rpc.ankr.com/polygon","https://polygon-rpc.com"],blockTime:2,confirmations:20,minValidBlock:4e7},43114:{rpcUrl:"https://avalanche-c-chain-rpc.publicnode.com",fallbackRpcUrls:["https://rpc.ankr.com/avalanche","https://api.avax.network/ext/bc/C/rpc"],blockTime:2,confirmations:1,minValidBlock:3e7},43113:{rpcUrl:"https://avalanche-fuji-c-chain-rpc.publicnode.com",fallbackRpcUrls:["https://rpc.ankr.com/avalanche_fuji","https://api.avax-test.network/ext/bc/C/rpc"],blockTime:2,confirmations:1,minValidBlock:2e7}};function createHash(o){const e="string"==typeof o?o:JSON.stringify(o);return Functions.keccak256(e)}async function getLatestBlockNumber(o){const e=CHAIN_CONFIGS[o];if(!e)throw new Error(`Unsupported chain ID: ${o}`);const r={jsonrpc:"2.0",method:"eth_blockNumber",params:[],id:Math.floor(1e6*Math.random())},t=[e.rpcUrl,...e.fallbackRpcUrls||[]];for(const e of t)try{console.log(`Getting latest block number from ${e}`);const t=await Functions.makeHttpRequest({url:e,method:"POST",headers:{"Content-Type":"application/json","User-Agent":"ChainlinkFunctions/1.0"},data:r,timeout:1e4});if(t.data&&t.data.result){const e=t.data.result,r=parseInt(e,16);return console.log(`Latest block on chain ${o}: ${r}`),r}}catch(o){console.log(`Failed to get latest block from ${e}: ${o.message}`)}throw new Error(`Could not get latest block number for chain ${o}`)}async function fetchBlockData(o,e){const r=CHAIN_CONFIGS[o];if(!r)throw new Error(`Unsupported chain ID: ${o}`);if(e<r.minValidBlock)return console.log(`Block ${e} is too old for chain ${o}, using mock data`),generateMockBlockData(o,e);if("true"===process.env.MOCK_DATA||e<0)return generateMockBlockData(o,Math.abs(e));const t={jsonrpc:"2.0",method:"eth_getBlockByNumber",params:[`0x${e.toString(16)}`,!0],id:Math.floor(1e6*Math.random())},a=[r.rpcUrl,...r.fallbackRpcUrls||[]];let n=null;for(let o=0;o<a.length;o++){const r=a[o];console.log(`Attempting to fetch block ${e} from ${r} (attempt ${o+1}/${a.length})`);try{const o=await Functions.makeHttpRequest({url:r,method:"POST",headers:{"Content-Type":"application/json","User-Agent":"ChainlinkFunctions/1.0"},data:t,timeout:15e3});if(!o.data)throw new Error(`No data returned from ${r}`);if(o.data.error){const e=o.data.error;if(console.log(`RPC Error from ${r}:`,JSON.stringify(e)),-32602===e.code||-32600===e.code)throw new Error(`Invalid request to ${r}: ${e.message}`);throw new Error(`RPC Error from ${r}: ${e.message} (Code: ${e.code})`)}if(!o.data.result)throw new Error(`Block ${e} not found on ${r}`);const a=o.data.result;if(!(a&&a.hash&&a.number&&a.timestamp))throw new Error(`Invalid block data structure from ${r}: ${JSON.stringify(a)}`);const n=parseInt(a.number,16);if(isNaN(n)||n!==e)throw new Error(`Block number mismatch from ${r}: expected ${e}, got ${n}`);if(!/^0x[a-fA-F0-9]{64}$/.test(a.hash))throw new Error(`Invalid block hash format from ${r}: ${a.hash}`);const c=parseInt(a.timestamp,16);if(c>Math.floor(Date.now()/1e3)+300)throw new Error(`Block timestamp ${c} from ${r} is in the future`);return console.log(`Successfully fetched block ${e} from ${r}`),a}catch(e){if(n=e,console.log(`Failed to fetch from ${r}: ${e.message}`),o===a.length-1)break;await new Promise(o=>setTimeout(o,1e3))}}return console.error(`All RPC endpoints failed for block ${e} on chain ${o}`),console.error("Last error:",n?.message),console.log(`Generating mock data for block ${e} as fallback`),generateMockBlockData(o,e)}function generateMockBlockData(o,e){const r=Math.floor(Date.now()/1e3)-12*e,t=`0x${Array(64).fill(0).map(()=>Math.floor(16*Math.random()).toString(16)).join("")}`,a=[],n=Math.floor(10*Math.random())+1;for(let o=0;o<n;o++)a.push({hash:`0x${Array(64).fill(0).map(()=>Math.floor(16*Math.random()).toString(16)).join("")}`,from:`0x${Array(40).fill(0).map(()=>Math.floor(16*Math.random()).toString(16)).join("")}`,to:`0x${Array(40).fill(0).map(()=>Math.floor(16*Math.random()).toString(16)).join("")}`,value:`0x${(Math.floor(1e6*Math.random())+1).toString(16)}`});return{hash:t,number:`0x${e.toString(16)}`,timestamp:`0x${r.toString(16)}`,transactions:a,parentHash:`0x${Array(64).fill(0).map(()=>Math.floor(16*Math.random()).toString(16)).join("")}`,stateRoot:`0x${Array(64).fill(0).map(()=>Math.floor(16*Math.random()).toString(16)).join("")}`,miner:`0x${Array(40).fill(0).map(()=>Math.floor(16*Math.random()).toString(16)).join("")}`}}function computeMerkleTree(o,e){if(!o||0===o.length)return"0x0000000000000000000000000000000000000000000000000000000000000000";const r=Math.pow(2,e),t=[...o];for(;t.length<r;)t.push(t[t.length-1]||"0x0000000000000000000000000000000000000000000000000000000000000000");let a=t.map(o=>createHash(o));for(;a.length>1;){const o=[];for(let e=0;e<a.length;e+=2){const r=a[e],t=createHash(r+(e+1<a.length?a[e+1]:r).replace("0x",""));o.push(t)}a=o}return a[0]}function generateMerklePath(o,e,r){if(e>=o.length)throw new Error("Leaf index out of bounds");const t=[],a=[],n=Math.pow(2,r),c=[...o];for(;c.length<n;)c.push(c[c.length-1]||"0x0000000000000000000000000000000000000000000000000000000000000000");let s=c.map(o=>createHash(o)),l=e;for(let o=0;o<r;o++){const o=l%2==0?l+1:l-1,e=o<s.length?s[o]:s[l];t.push(e),a.push(l%2);const r=[];for(let o=0;o<s.length;o+=2){const e=s[o],t=o+1<s.length?s[o+1]:e;r.push(createHash(e+t.replace("0x","")))}s=r,l=Math.floor(l/2)}return{pathElements:t,pathIndices:a}}function validateBlockData(o,e){if(!o)throw new Error("Block data is null");if(!o.hash||!o.number||!o.timestamp)throw new Error("Invalid block data structure");if(!/^0x[a-fA-F0-9]{64}$/.test(o.hash))throw new Error("Invalid block hash format");const r=parseInt(o.timestamp,16),t=Math.floor(Date.now()/1e3),a=t-2592e3;if("true"!==process.env.MOCK_DATA&&(r<a||r>t+300))throw new Error("Block timestamp out of reasonable range");return!0}function prepareCircuitInputs(o,e,r,t){const a=[];for(let n=0;n<o.length;n++){const c=o[n];validateBlockData(c,e);const s=c.transactions.map(o=>"string"==typeof o?o:o.hash);0===s.length&&s.push(c.hash);const l=computeMerkleTree(s,t),i=generateMerklePath(s,0,t),h={blockHash:c.hash,chainId:e,merkleRoot:l,leaf:s[0],pathElements:i.pathElements,pathIndices:i.pathIndices,targetChainId:r,blockNumber:parseInt(c.number,16),timestamp:parseInt(c.timestamp,16)};a.push(h)}return a}async function requestExternalProofGeneration(o,e){if(!e||""===e)return{status:"inputs_prepared",message:"Circuit inputs prepared - no external service configured",circuitInputs:o};try{const r={circuit:"proof_aggregator",inputs:o,params:{nProofs:o.length,merkleDepth:merkleDepth,blockDepth:8}};console.log(`Attempting to call external proof service at: ${e}`),console.log("Proof request payload:",JSON.stringify(r,null,2));const t=await Functions.makeHttpRequest({url:e,method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json","User-Agent":"ChainlinkFunctions/1.0"},data:r,timeout:6e4});if(console.log("HTTP Response status:",t.status),console.log("HTTP Response data:",JSON.stringify(t.data,null,2)),t.error)throw console.error("Proof service HTTP error:",JSON.stringify(t.error)),new Error(`Proof service error: ${JSON.stringify(t.error)}`);if(!t.data)throw console.error("No response data received from proof service"),new Error("No response data received from proof service");if(!1===t.data.success)throw console.error("Proof service returned failure:",t.data.error),new Error(`Proof service failed: ${t.data.error}`);return console.log("Successfully received proof from external service"),t.data}catch(e){if(console.error("External proof generation failed:",e.message),console.error("Full error details:",JSON.stringify(e,Object.getOwnPropertyNames(e))),"true"===process.env.MOCK_DATA)return console.log("MOCK_DATA=true, returning mock proof result"),generateMockProofResult(o);throw new Error(`Real proof generation failed: ${e.message}`)}}function generateMockProofResult(o){return{status:"proof_generated",proof:{pi_a:["19977388743896285994233602017122229905376581404968734105843487057334449066219","7031682385824214205052254702752430476895865313831979018605709946148180045575","1"],pi_b:[["12720396135861753409360003892079332281980285975874504377152366515594545980863","2785878884372585793274394960064441358906130242999989133558408040959123010970"],["2897334897353034376053909262581081489252861230613586337332095339732705435267","20706222872013252346113316831691184232572126896896428063411823552342235289107"],["1","0"]],pi_c:["2946774739632969350855685573451598285113123648875877679414511841910111064679","14834010604054493081432533047034793326416578351806602401256397141481808453727","1"],protocol:"groth16"},publicSignals:o.map((o,e)=>`${1e46+e}`),isValid:!0,circuitInputs:o,metadata:{circuit:"proof_aggregator",generationTime:50,verifiedLocally:!0,isMock:!0}}}async function main(){try{if(console.log(`Starting ZK proof data preparation for chain ${chainId}`),console.log(`Block numbers: ${JSON.stringify(blockNumbers)}`),console.log(`Target chain: ${targetChainId}`),console.log(`Merkle depth: ${merkleDepth}`),console.log(`Proof service URL: ${proofServiceUrl}`),!Array.isArray(blockNumbers)||0===blockNumbers.length)throw new Error("Invalid block numbers array");if(!CHAIN_CONFIGS[chainId])throw new Error(`Unsupported source chain ID: ${chainId}`);const o=CHAIN_CONFIGS[chainId];let e=[];for(const r of blockNumbers)if(r<o.minValidBlock){console.log(`Block ${r} is too old for chain ${chainId}, trying to get recent block`);try{const t=await getLatestBlockNumber(chainId);if(t&&t>o.minValidBlock)console.log(`Using recent block ${t} instead of ${r}`),e.push(t-Math.floor(100*Math.random()));else{const r=o.minValidBlock+Math.floor(1e6*Math.random());console.log(`Could not get latest block, using estimated block ${r}`),e.push(r)}}catch(r){console.log(`Could not get latest block: ${r.message}, using estimated block`);const t=o.minValidBlock+Math.floor(1e6*Math.random());e.push(t)}}else e.push(r);console.log(`Adjusted block numbers: ${JSON.stringify(e)}`);const r=[];let t=0,a=0;for(const o of e){console.log(`Fetching block ${o} for chain ${chainId}`);try{const n=await fetchBlockData(chainId,o);if(n)try{validateBlockData(n,chainId),r.push(n),t++,console.log(`Successfully validated block ${o} data (${t}/${e.length})`)}catch(e){console.error(`Block ${o} validation failed: ${e.message}`),a++}else console.warn(`No data for block ${o}, skipping`),a++}catch(e){console.error(`Error fetching block ${o}: ${e.message}`),a++}}if(console.log(`Block fetching summary: ${t} successful, ${a} failed`),0===r.length){const e=["No valid block data retrieved.",`Chain ${chainId} requires blocks >= ${o.minValidBlock}.`,`Requested blocks: ${JSON.stringify(blockNumbers)}.`,`Tried endpoints: ${[o.rpcUrl,...o.fallbackRpcUrls||[]].join(", ")}.`,"Consider using more recent block numbers or check network connectivity."].join(" ");throw new Error(e)}console.log(`Successfully fetched ${r.length} blocks`);const n=prepareCircuitInputs(r,chainId,targetChainId,merkleDepth);let c;console.log("Prepared circuit inputs for real ZK proof generation");let s=null;try{c=await requestExternalProofGeneration(n,proofServiceUrl),console.log(`Proof generation status: ${c.status}`)}catch(o){console.error(`Failed to generate proof via external service: ${o.message}`),s=o.message,c={status:"external_service_failed",error:o.message,circuitInputs:n,metadata:{circuit:"proof_aggregator",generationTime:0,verifiedLocally:!1,isMock:!1,failureReason:o.message}}}const l=createHash(JSON.stringify(n)),i=!(!c.proof||!c.publicSignals),h={s:!0,c:chainId,t:targetChainId,b:r.length,h:l.slice(0,16),p:i?1:0,ps:c.status.slice(0,20),ts:Math.floor(Date.now()/1e3)},p=JSON.stringify(h);return console.log("ZK proof data preparation completed successfully"),console.log(`Compact result size: ${p.length} characters`),console.log(`Result: ${p}`),console.log(`Real proof generated: ${i}`),console.log("Full circuit inputs for external service:"),console.log(JSON.stringify(n)),Functions.encodeString(p)}catch(o){console.error("Error in ZK proof data preparation:",o.message),console.error("Stack trace:",o.stack);const e={s:!1,e:o.message.slice(0,100),c:chainId||0,t:targetChainId||0,ts:Math.floor(Date.now()/1e3)},r=JSON.stringify(e);return console.log(`Error result size: ${r.length} characters`),console.log(`Error result: ${r}`),Functions.encodeString(r)}}(async()=>{await main()})();